{"paragraphs":[{"text":"%md\n## Clustering of Seed Data\n\nIn this lab, you have a data set of seeds. Each entry contains properties about some seed like length, width, compactness, etc.\nUnfortunately, you do not know which of the seed is from which plant (i.e. there is no label for that in the data).\n\nHere's a sneak peek at the data (file is located under *\"/user/zeppelin/seeds_dataset.csv\"*):\n\n    area,perimeter,compactness,length_of_kernel,width_of_kernel,asymmetry_coefficient,length_of_groove\n    15.26,14.84,0.871,5.763,3.312,2.221,5.22\n    14.88,14.57,0.8811,5.553999999999999,3.333,1.018,4.956\n    14.29,14.09,0.905,5.291,3.3369999999999997,2.699,4.825\n\nHaving no lables about the plants, you would still like to analyse how many different types of seed there are in the data.\nBuild a pipeline that does k-means and use the elbow method to find a reasonable amount of clusters!\n\n### Pipeline components to implement\nImplement the following components:\n1. Read in data\n2. Assemble available features\n3. Normalize features\n4. Cluster with k-means for a fixed number of clusters, e.g. 5\n5. Evaluate k-means by computing distortion (sum of squared means from cluster centroids)\n\n### Elbow method to find best k\nAs soon as your pipeline works for a fixed number of clusters, find the best value for k with the elbow method.\nA simple way to do that would be:\n- Build a loop around steps 4 & 5 above to run it for different values of k (e.g. 2 to 10)\n- Append a tuple (k, cost) to a list in each step of the iteration\n- Transform the list to a DataFrame, register it as SQL table and plot the curve with the built in Zeppelin SQL visualizer\n\n### Optional: Comparing regular k-Means and hierarchical k-Means version\nSince plant families can themselves be modeled as hierarchical structures, it might be a good idea to also cluster their seeds hierarchically.\nThere is a hierarchical version of the k-means algorithm, called bisecting k-means. It works by splitting the data into clusters in a top-down approach\n(starting with all points in one cluster and splitting it up into more clusters consecutively).\n\nBuild a second pipeline that uses the same normalized features and clusters them with bisecting k-means.\nCalculate the cost for different values of k, plot it and compare it with the regular k-means algorithm. Does it make any difference?","user":"admin","dateUpdated":"2019-02-13T17:15:24+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Clustering of Seed Data</h2>\n<p>In this lab, you have a data set of seeds. Each entry contains properties about some seed like length, width, compactness, etc.\n<br  />Unfortunately, you do not know which of the seed is from which plant (i.e. there is no label for that in the data).</p>\n<p>Here's a sneak peek at the data (file is located under <em>&ldquo;/user/zeppelin/seeds_dataset.csv&rdquo;</em>):</p>\n<pre><code>area,perimeter,compactness,length_of_kernel,width_of_kernel,asymmetry_coefficient,length_of_groove\n15.26,14.84,0.871,5.763,3.312,2.221,5.22\n14.88,14.57,0.8811,5.553999999999999,3.333,1.018,4.956\n14.29,14.09,0.905,5.291,3.3369999999999997,2.699,4.825\n</code></pre>\n<p>Having no lables about the plants, you would still like to analyse how many different types of seed there are in the data.\n<br  />Build a pipeline that does k-means and use the elbow method to find a reasonable amount of clusters!</p>\n<h3>Pipeline components to implement</h3>\n<p>Implement the following components:</p>\n<ol>\n<li>Read in data</li>\n<li>Assemble available features</li>\n<li>Normalize features</li>\n<li>Cluster with k-means for a fixed number of clusters, e.g. 5</li>\n<li>Evaluate k-means by computing distortion (sum of squared means from cluster centroids)</li>\n</ol>\n<h3>Elbow method to find best k</h3>\n<p>As soon as your pipeline works for a fixed number of clusters, find the best value for k with the elbow method.\n<br  />A simple way to do that would be:</p>\n<ul>\n<li>Build a loop around steps 4 &amp; 5 above to run it for different values of k (e.g. 2 to 10)</li>\n<li>Append a tuple (k, cost) to a list in each step of the iteration</li>\n<li>Transform the list to a DataFrame, register it as SQL table and plot the curve with the built in Zeppelin SQL visualizer</li>\n</ul>\n<h3>Optional: Comparing regular k-Means and hierarchical k-Means version</h3>\n<p>Since plant families can themselves be modeled as hierarchical structures, it might be a good idea to also cluster their seeds hierarchically.\n<br  />There is a hierarchical version of the k-means algorithm, called bisecting k-means. It works by splitting the data into clusters in a top-down approach\n<br  />(starting with all points in one cluster and splitting it up into more clusters consecutively).</p>\n<p>Build a second pipeline that uses the same normalized features and clusters them with bisecting k-means.\n<br  />Calculate the cost for different values of k, plot it and compare it with the regular k-means algorithm. Does it make any difference?</p>\n"}]},"apps":[],"jobName":"paragraph_1550078124871_893274853","id":"20190213-082259_722661528","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:54478"},{"title":"Read Data from File","text":"// TODO: read in data from the source provided above\n\n???","user":"admin","dateUpdated":"2019-02-13T17:16:21+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124872_140182348","id":"20190213-090826_415289920","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54479"},{"title":"ML Pipeline Part 1: Assemble and Scale Features","text":"// TODO: build the first part of your ML model pipeline:\n// - assembling the data features \n// - scaling the features \n\nimport org.apache.spark.ml.{Pipeline, PipelineModel}\nimport org.apache.spark.ml.feature.{VectorAssembler, StandardScaler}\n\n???","user":"admin","dateUpdated":"2019-02-13T17:16:10+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124872_-567890030","id":"20190213-121642_789654883","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54480"},{"title":"ML Pipeline Part 2: Cluster Data","text":"// TODO: build the second part of your ML model pipeline:\n// - add a k-means model that uses your scaled features as last step \n// - assemble all the steps into one ML pipeline\n// - fit pipeline to data\n// - cluster data\n// - calculate clustering cost (hint: the KMeansModel class provides a convenient method for that, called computeCost)\n\nimport org.apache.spark.ml.{Pipeline, PipelineModel}\nimport org.apache.spark.ml.clustering.{KMeans, KMeansModel, BisectingKMeans, BisectingKMeansModel}\n\n???\n\n","user":"admin","dateUpdated":"2019-02-13T17:19:00+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124873_-1895591988","id":"20190209-164648_1183645036","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54481"},{"title":"Run Clustering For Different Values of K","text":"// TODO: as soon as the pipeline above is working, put a for-loop around to iterate over it and calculate the cost for different values of k\n// then build a DataFrame of the results, register it for SQL access and visualize k vs. cost with the built-in Zeppelin SQL tools\n\n// Scala hint to add something to a list: declare it as \"var ... List...\" and then use the \".+\" operator to append entries\n\n???","user":"admin","dateUpdated":"2019-02-13T17:20:14+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124873_623260003","id":"20190213-154749_1386842582","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54482"},{"title":"Visualize K vs. Error","text":"%sql\n???\n","user":"admin","dateUpdated":"2019-02-13T17:15:24+0000","config":{"editorSetting":{"language":"sql","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/sql","fontSize":9,"title":true,"results":{"0":{"graph":{"mode":"lineChart","height":300,"optionOpen":false,"setting":{"table":{"tableGridState":{},"tableColumnTypeState":{"names":{"k":"string","error":"string"},"updated":false},"tableOptionSpecHash":"[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]","tableOptionValue":{"useFilter":false,"showPagination":false,"showAggregationFooter":false},"updated":false,"initialized":false},"multiBarChart":{"rotate":{"degree":"-45"},"xLabelStatus":"default"},"lineChart":{"xLabelStatus":"default","rotate":{"degree":"-45"}},"stackedAreaChart":{"rotate":{"degree":"-45"},"xLabelStatus":"default"}},"commonSetting":{},"keys":[{"name":"k","index":0,"aggr":"sum"}],"groups":[],"values":[{"name":"error","index":1,"aggr":"sum"}]},"helium":{}}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124873_-2116299343","id":"20190213-141053_2095352762","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54483"},{"text":"// if you're done: don't forget to compare the regular k-means with the bisecting k-means (see task description on top for details= ","user":"admin","dateUpdated":"2019-02-13T17:21:24+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1550078124874_-760964533","id":"20190213-161843_1114512948","dateCreated":"2019-02-13T17:15:24+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:54484"}],"name":"Day4_ML_Labs/Clustering/Clustering_Medium","id":"2E36F8GXA","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"jdbc:shared_process":[],"spark2:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}